#!/usr/bin/env python3
"""
gask-w - Send message to Gemini and wait for reply (pure sync mode)
Designed to be run with Claude Code's run_in_background=true
"""
from __future__ import annotations
import os
import sys
from pathlib import Path
import json

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))
from compat import setup_windows_encoding
from output import emoji, spinner_chars, is_tty
setup_windows_encoding()


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        print("Usage: gask-w <message>", file=sys.stderr)
        return 1

    message = " ".join(argv[1:]).strip()
    if not message:
        print(f"{emoji('‚ùå')} Message cannot be empty", file=sys.stderr)
        return 1

    from gemini_comm import GeminiCommunicator
    from i18n import t

    def save_pending_state(state: dict) -> None:
        session_file = Path.cwd() / ".gemini-session"
        if not session_file.exists():
            return
        try:
            with session_file.open("r", encoding="utf-8-sig") as handle:
                data = json.load(handle)
            data["pending_state"] = {
                "session_path": str(state.get("session_path")) if state.get("session_path") else None,
                "msg_count": int(state.get("msg_count", 0) or 0),
                "mtime": float(state.get("mtime", 0.0) or 0.0),
                "mtime_ns": int(state.get("mtime_ns", 0) or 0),
                "size": int(state.get("size", 0) or 0),
                "last_gemini_id": state.get("last_gemini_id"),
                "last_gemini_hash": state.get("last_gemini_hash"),
            }
            tmp_file = session_file.with_suffix(".tmp")
            with tmp_file.open("w", encoding="utf-8") as handle:
                json.dump(data, handle, ensure_ascii=False, indent=2)
            os.replace(tmp_file, session_file)
        except Exception:
            return

    # Save to cache
    cache_dir = Path.home() / ".cache" / "ccb"
    cache_dir.mkdir(parents=True, exist_ok=True)
    reply_file = cache_dir / "gemini_last_reply.txt"
    # Clear stale cache
    if reply_file.exists():
        try:
            reply_file.unlink()
        except Exception:
            pass

    try:
        comm = GeminiCommunicator(lazy_init=True)

        # Check session health
        healthy, status = comm._check_session_health_impl(probe_terminal=False)
        if not healthy:
            # Interactive recovery: ask user if they want to start the session
            if sys.stdin.isatty():
                print(f"{emoji('‚ö†Ô∏è')}  Gemini session not active: {status}", file=sys.stderr)
                try:
                    response = input("Start Gemini now? [Y/n]: ").strip().lower()
                except (EOFError, KeyboardInterrupt):
                    response = "n"

                if response in ("", "y", "yes"):
                    print(f"{emoji('üöÄ')} Starting Gemini...", flush=True)
                    from launcher import AILauncher
                    launcher = AILauncher(providers=["gemini"], resume=False, auto=False, no_claude=True)
                    result = launcher.run_up()
                    if result != 0:
                        print(f"{emoji('‚ùå')} Failed to start Gemini", file=sys.stderr)
                        return 1
                    # Wait for session to become healthy with polling (max 10s)
                    import time
                    max_wait = 10.0
                    poll_interval = 0.5
                    waited = 0.0
                    healthy = False
                    while waited < max_wait:
                        time.sleep(poll_interval)
                        waited += poll_interval
                        comm = GeminiCommunicator(lazy_init=True)
                        healthy, status = comm._check_session_health_impl(probe_terminal=False)
                        if healthy:
                            break
                        if is_tty():
                            print(f"\r{emoji('‚è≥')} Waiting for Gemini to be ready... ({waited:.0f}s)   ", end="", flush=True)
                        else:
                            print(f"{emoji('‚è≥')} Waiting for Gemini... ({waited:.0f}s)", flush=True)
                    if is_tty():
                        print("\r" + " " * 50 + "\r", end="", flush=True)  # Clear line
                    if not healthy:
                        print(f"{emoji('‚ùå')} Session not ready after {max_wait:.0f}s: {status}", file=sys.stderr)
                        return 1
                    print(f"{emoji('‚úÖ')} Gemini started successfully", flush=True)
                else:
                    print(f"{emoji('‚ùå')} Cancelled", file=sys.stderr)
                    return 1
            else:
                print(f"{emoji('‚ùå')} Session error: {status}", file=sys.stderr)
                return 1

        # Wait for pane to become idle before sending (avoid interrupting AI output)
        from pane_idle import wait_for_pane_idle, should_skip_idle_check
        if comm.pane_id and not should_skip_idle_check():
            terminal = getattr(comm, 'terminal_type', 'wezterm') or 'wezterm'
            idle, waited = wait_for_pane_idle(comm.pane_id, terminal)
            if not idle and is_tty():
                print(f"{emoji('‚ö†Ô∏è')}  Pane still busy after {waited:.1f}s, sending anyway...", file=sys.stderr)

        # Send message
        print(f"{emoji('üîî')} {t('sending_to', provider='Gemini')}", flush=True)
        marker, state = comm._send_payload(message)
        comm._remember_session(state.get("session_path") or comm.log_reader.current_log_path())

        # Pure sync wait with heartbeat (default 1 hour, configurable via CCB_SYNC_TIMEOUT)
        sync_timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "3600.0"))
        # Progressive heartbeat: starts at 2s, increases to 5s, then 10s
        heartbeat_intervals = [2.0, 2.0, 2.0, 5.0, 5.0, 10.0]  # First 3 at 2s, next 2 at 5s, then 10s
        heartbeat_idx = 0
        # Spinner characters for dynamic feedback (TTY-aware)
        spin_chars = spinner_chars()
        spinner_idx = 0

        # Wait with periodic heartbeat to let Claude know we're still waiting
        # Use monotonic clock to avoid issues with system time changes
        import time
        start_time = time.monotonic()
        message_reply = None
        last_heartbeat = start_time

        while True:
            # Calculate elapsed and remaining time at loop start
            elapsed = time.monotonic() - start_time
            remaining = sync_timeout - elapsed
            if remaining <= 0:
                break

            # Get current heartbeat interval (progressive)
            current_interval = heartbeat_intervals[min(heartbeat_idx, len(heartbeat_intervals) - 1)]

            # Ensure minimum wait time to avoid CPU spin
            chunk_timeout = max(0.1, min(current_interval, remaining))
            message_reply, new_state = comm.log_reader.wait_for_message(state, chunk_timeout)
            state = new_state or state
            if message_reply:
                break

            # Output heartbeat if interval passed
            now = time.monotonic()
            if now - last_heartbeat >= current_interval:
                spinner = spin_chars[spinner_idx % len(spin_chars)]
                spinner_idx += 1
                if is_tty():
                    print(f"\r{spinner} Waiting for Gemini... ({int(elapsed)}s)   ", end="", flush=True)
                else:
                    print(f"{spinner} Waiting for Gemini... ({int(elapsed)}s)", flush=True)
                last_heartbeat = now
                heartbeat_idx += 1

        # Clear the spinner line before output
        if spinner_idx > 0 and is_tty():
            print("\r" + " " * 40 + "\r", end="", flush=True)

        comm._remember_session(state.get("session_path") or comm.log_reader.current_log_path())

        # Save to cache
        cache_dir = Path.home() / ".cache" / "ccb"
        cache_dir.mkdir(parents=True, exist_ok=True)
        reply_file = cache_dir / "gemini_last_reply.txt"

        if message_reply:
            print(f"{emoji('ü§ñ')} {t('reply_from', provider='Gemini')}")
            print(message_reply)
            reply_file.write_text(message_reply, encoding="utf-8")
        else:
            print(f"{emoji('‚è∞')} Timeout after {int(sync_timeout)}s")
            save_pending_state(state)
        return 0

    except KeyboardInterrupt:
        try:
            save_pending_state(locals().get("state", {}) if isinstance(locals().get("state"), dict) else {})
        except Exception:
            pass
        print(f"{emoji('‚ùå')} Interrupted", file=sys.stderr)
        return 130
    except Exception as exc:
        print(f"{emoji('‚ùå')} {exc}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
