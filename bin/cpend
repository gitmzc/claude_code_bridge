#!/usr/bin/env python3
"""
cpend - View latest Codex reply or recent N conversations

Usage:
  cpend        # View latest reply
  cpend N      # View last N Q&A pairs (e.g., cpend 3)
"""

import json
import sys
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))
from compat import setup_windows_encoding
setup_windows_encoding()

from i18n import t
from session_utils import safe_write_session

try:
    from codex_comm import CodexCommunicator
except ImportError as exc:
    print(f"Import failed: {exc}")
    sys.exit(1)


def _load_cached_reply() -> str | None:
    """Load cached reply from background cask-w process"""
    cache_file = Path.home() / ".cache" / "ccb" / "codex_last_reply.txt"
    if not cache_file.exists():
        return None
    try:
        content = cache_file.read_text(encoding="utf-8").strip()
        if content:
            cache_file.unlink()  # Clear after reading
            return content
    except Exception:
        pass
    return None


def _load_pending_state() -> dict:
    """Load pending state saved by cask-w timeout from .codex-session"""
    session_file = Path.cwd() / ".codex-session"
    if not session_file.exists():
        return {}
    try:
        with session_file.open("r", encoding="utf-8-sig") as f:
            data = json.load(f)
        pending = data.get("pending_state", {})
        return pending if isinstance(pending, dict) else {}
    except Exception:
        return {}


def _clear_pending_state() -> None:
    """Clear pending_state"""
    session_file = Path.cwd() / ".codex-session"
    if not session_file.exists():
        return
    try:
        with session_file.open("r", encoding="utf-8-sig") as f:
            data = json.load(f)
        if "pending_state" in data:
            del data["pending_state"]
            safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))
    except Exception:
        pass


def _print_conversations(conversations: list[dict]) -> None:
    """Print Q&A pairs in formatted output"""
    for i, conv in enumerate(conversations):
        print(f"Q: {conv['question']}")
        print(f"A: {conv['answer']}")
        if i < len(conversations) - 1:
            print("---")


def main() -> int:
    # Parse N argument
    n_conversations = 0
    if len(sys.argv) > 1:
        try:
            n_conversations = int(sys.argv[1])
            if n_conversations < 1:
                print("Error: N must be a positive integer (>= 1)")
                print("Usage: cpend [N]  # N = number of recent conversations to show")
                return 1
        except ValueError:
            print(f"Invalid argument: {sys.argv[1]}")
            print("Usage: cpend [N]  # N = number of recent conversations to show")
            return 1

    try:
        # If N is specified, show recent N conversations
        if n_conversations > 0:
            comm = CodexCommunicator(lazy_init=True)
            conversations = comm.log_reader.latest_conversations(n_conversations)
            if conversations:
                _print_conversations(conversations)
            else:
                print(t('no_reply_available', provider='Codex'))
            return 0

        # Default behavior: show latest reply
        # First check cached reply from background cask-w
        cached = _load_cached_reply()
        if cached:
            print(f"ü§ñ Codex reply:")
            print(cached)
            return 0

        comm = CodexCommunicator()

        pending = _load_pending_state()
        if pending and pending.get("log_path"):
            try:
                log_path = Path(str(pending.get("log_path"))).expanduser()
            except Exception:
                log_path = None

            # Avoid falling back to "global latest" if the pending log path is missing,
            # otherwise cpend may display an unrelated reply from another project.
            if log_path and log_path.exists():
                try:
                    offset = int(pending.get("offset", 0) or 0)
                except Exception:
                    offset = 0
                state = {"log_path": str(log_path), "offset": offset}
                message, _ = comm.log_reader.try_get_message(state)
                if message:
                    _clear_pending_state()
                    print(message)
                    return 0

        output = comm.consume_pending(display=False)
        if output:
            print(output)
        else:
            print(t('no_reply_available', provider='Codex'))
        return 0
    except Exception as exc:
        print(f"‚ùå {t('execution_failed', error=exc)}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
