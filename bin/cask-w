#!/usr/bin/env python3
"""
cask-w - Send message to Codex and wait for reply (pure sync mode)
Designed to be run with Claude Code's run_in_background=true
"""
from __future__ import annotations
import os
import sys
from pathlib import Path
import json

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))
from compat import setup_windows_encoding
setup_windows_encoding()


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        print("Usage: cask-w <message>", file=sys.stderr)
        return 1

    message = " ".join(argv[1:]).strip()
    if not message:
        print("‚ùå Message cannot be empty", file=sys.stderr)
        return 1

    from codex_comm import CodexCommunicator
    from i18n import t

    def save_pending_state(state: dict) -> None:
        session_file = Path.cwd() / ".codex-session"
        if not session_file.exists():
            return
        try:
            with session_file.open("r", encoding="utf-8-sig") as handle:
                data = json.load(handle)
            data["pending_state"] = {
                "log_path": str(state.get("log_path")) if state.get("log_path") else None,
                "offset": int(state.get("offset", 0) or 0),
            }
            tmp_file = session_file.with_suffix(".tmp")
            with tmp_file.open("w", encoding="utf-8") as handle:
                json.dump(data, handle, ensure_ascii=False, indent=2)
            os.replace(tmp_file, session_file)
        except Exception:
            return

    try:
        comm = CodexCommunicator(lazy_init=True)

        # Check session health
        healthy, status = comm._check_session_health_impl(probe_terminal=False)
        if not healthy:
            print(f"‚ùå Session error: {status}", file=sys.stderr)
            return 1

        # Send message
        print(f"üîî {t('sending_to', provider='Codex')}", flush=True)
        marker, state = comm._send_message(message)
        comm._remember_codex_session(state.get("log_path") or comm.log_reader.current_log_path())

        # Pure sync wait with heartbeat (default 1 hour, configurable via CCB_SYNC_TIMEOUT)
        sync_timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "3600.0"))
        heartbeat_interval = float(os.environ.get("CCB_HEARTBEAT_INTERVAL", "30.0"))

        # Wait with periodic heartbeat to let Claude know we're still waiting
        import time
        start_time = time.time()
        message_reply = None
        last_heartbeat = start_time

        while True:
            # Try to get message with short timeout
            chunk_timeout = min(heartbeat_interval, sync_timeout - (time.time() - start_time))
            if chunk_timeout <= 0:
                break
            message_reply, state = comm.log_reader.wait_for_message(state, chunk_timeout)
            if message_reply:
                break

            # Output heartbeat if interval passed
            elapsed = time.time() - start_time
            if time.time() - last_heartbeat >= heartbeat_interval:
                print(f"‚è≥ Still waiting for Codex... ({int(elapsed)}s elapsed)", flush=True)
                last_heartbeat = time.time()

            # Check total timeout
            if elapsed >= sync_timeout:
                break

        # Save to cache
        cache_dir = Path.home() / ".cache" / "ccb"
        cache_dir.mkdir(parents=True, exist_ok=True)
        reply_file = cache_dir / "codex_last_reply.txt"

        if message_reply:
            print(f"ü§ñ {t('reply_from', provider='Codex')}")
            print(message_reply)
            reply_file.write_text(message_reply, encoding="utf-8")
        else:
            print(f"‚è∞ Timeout after {int(sync_timeout)}s")
            save_pending_state(state)
        return 0

    except KeyboardInterrupt:
        # Best-effort: preserve pending state so /cpend can fetch later.
        try:
            save_pending_state(locals().get("state", {}) if isinstance(locals().get("state"), dict) else {})
        except Exception:
            pass
        print("‚ùå Interrupted", file=sys.stderr)
        return 130
    except Exception as exc:
        print(f"‚ùå {exc}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
