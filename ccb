#!/usr/bin/env python3
"""
ccb (Claude Code Bridge) - Unified AI Launcher
Supports Claude + Codex / Claude + Gemini / all three simultaneously
Supports WezTerm and iTerm2 terminals
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import platform
import tempfile
import re
from pathlib import Path

script_dir = Path(__file__).resolve().parent
sys.path.insert(0, str(script_dir / "lib"))
from terminal import WeztermBackend, Iterm2Backend, detect_terminal, is_wsl, get_shell_type
from compat import setup_windows_encoding
from ccb_config import get_backend_env
from session_utils import safe_write_session, check_session_writable
from i18n import t
from path_utils import (
    normalize_path_for_match,
    work_dir_match_keys,
    extract_session_work_dir_norm,
)
from updater import (
    get_version_info,
    format_version_info,
    get_remote_version_info,
    update_from_git,
    update_from_tarball,
)
from constants import VERSION, VALID_PROVIDERS
from launcher import AILauncher
from doctor import run_diagnostics
from init_wizard import run_init_wizard
from output import init_output, is_quiet, is_json, is_debug, print_msg, print_error, print_debug, print_debug_exception, set_output, add_to_list, flush_json
from errors import ExitCode, format_error, print_error_and_exit
from broadcast import parallel_ask, format_results, cmd_ask

setup_windows_encoding()


def print_custom_help():
    """Print custom formatted help with grouped commands."""
    help_text = """ccb (Claude Code Bridge) - AI Backend Unified Launcher

Usage: ccb [options] <command> [args]

Session Commands:
  up [providers]      Start AI backends (codex, gemini)
                      -r, --resume    Resume previous context
                      -a, --auto      Full auto permission mode
                      --no-claude     Don't start Claude main window
  status [providers]  Check backend status
  kill [providers]    Terminate running sessions
  restore [providers] Restore/attach to existing session

Communication Commands:
  ask [message]       Send message to AI providers in parallel
                      -p, --providers Comma-separated providers (default: all)
                      -a, --all       Send to all providers
                      -w, --wait      Wait for replies (default)
                      --no-wait       Fire and forget mode
                      -t, --timeout   Timeout in seconds (0=unlimited)

System Commands:
  init                Interactive configuration wizard
                      -c, --config    Path to save config file
                      -f, --force     Overwrite existing config
  doctor              Run system diagnostics
                      -v, --verbose   Verbose output
  update              Update ccb to latest version
  version             Show version and check for updates
  completion [shell]  Output shell completion script (default: zsh)

Global Options:
  -q, --quiet         Suppress non-essential output
  --json              Output in JSON format
  --debug             Enable debug output for troubleshooting
  -h, --help          Show this help message

Examples:
  ccb up codex              Start Codex backend
  ccb up codex gemini       Start both backends
  ccb up -r                 Resume with previous context
  ccb status                Check all backend status
  ccb kill codex            Terminate Codex session
  ccb doctor                Run diagnostics

For more information, visit: https://github.com/gitmzc/claude_code_bridge
"""
    print(help_text.strip())

backend_env = get_backend_env()
if backend_env and not os.environ.get("CCB_BACKEND_ENV"):
    os.environ["CCB_BACKEND_ENV"] = backend_env


def cmd_up(args):
    launcher = AILauncher(
        providers=args.providers or ["codex"],
        resume=args.resume,
        auto=args.auto,
        no_claude=args.no_claude,
    )
    return launcher.run_up()


def cmd_status(args):
    providers = args.providers or ["codex", "gemini"]
    results = {}
    print_debug(f"Checking status for providers: {providers}")

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        print_debug(f"Looking for session file: {session_file}")
        if not session_file.exists():
            results[provider] = {"status": "Not configured", "active": False}
            print_debug(f"{provider}: session file not found")
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            print_debug(f"{provider}: loaded session data", json.dumps(data, indent=2))
            terminal = data.get("terminal", "wezterm")
            pane_id = data.get("pane_id", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                alive = backend.is_alive(pane_id)
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                alive = backend.is_alive(pane_id)
            else:
                alive = False

            results[provider] = {
                "status": "Running" if (active and alive) else "Stopped",
                "active": active and alive,
                "terminal": terminal,
                "pane_id": pane_id,
                "runtime_dir": data.get("runtime_dir", ""),
            }
        except Exception as e:
            results[provider] = {"status": f"Error: {e}", "active": False}

    if is_json():
        set_output("providers", results)
        return flush_json(0)

    print_msg(f"üìä {t('backend_status')}")
    for provider, info in results.items():
        icon = "‚úÖ" if info.get("active") else "‚ùå"
        print_msg(f"  {icon} {provider.capitalize()}: {info['status']}")
        if info.get("pane_id"):
            print_msg(f"     {info.get('terminal', 'wezterm')}: {info['pane_id']}")

    return 0


def cmd_kill(args):
    providers = args.providers or ["codex", "gemini"]
    results = []

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print_msg(f"‚ö†Ô∏è {provider}: Session file not found")
            results.append({"provider": provider, "success": False, "error": "Session file not found"})
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            terminal = data.get("terminal", "wezterm")
            pane_id = data.get("pane_id", "")

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                backend.kill_pane(pane_id)
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                backend.kill_pane(pane_id)

            data["active"] = False
            data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
            safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))

            print_msg(f"‚úÖ {provider.capitalize()} terminated")
            results.append({"provider": provider, "success": True})
        except Exception as e:
            print_error(f"‚ùå {provider}: {e}")
            results.append({"provider": provider, "success": False, "error": str(e)})

    if is_json():
        set_output("results", results)
        return flush_json(0)

    return 0


def cmd_restore(args):
    providers = args.providers or ["codex"]

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print(f"‚ö†Ô∏è {provider}: Session file not found")
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            terminal = data.get("terminal", "wezterm")
            pane_id = data.get("pane_id", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                if backend.is_alive(pane_id):
                    backend.activate(pane_id)
                    return 0
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                if backend.is_alive(pane_id):
                    backend.activate(pane_id)
                    return 0

            if not active:
                has_history = False
                session_id = None
                if provider == "codex":
                    session_id = data.get("codex_session_id")
                    if isinstance(session_id, str) and session_id:
                        recorded_norm = extract_session_work_dir_norm(data)
                        work_keys = work_dir_match_keys(Path.cwd())
                        if recorded_norm and (not work_keys or recorded_norm in work_keys):
                            has_history = True
                        else:
                            session_id = None
                    else:
                        # Fallback: scan ~/.codex/sessions for latest session bound to this cwd.
                        root = Path(os.environ.get("CODEX_SESSION_ROOT") or (Path.home() / ".codex" / "sessions")).expanduser()
                        work_dirs = work_dir_match_keys(Path.cwd())
                        try:
                            logs = sorted(
                                (p for p in root.glob("**/*.jsonl") if p.is_file()),
                                key=lambda p: p.stat().st_mtime,
                                reverse=True,
                            )
                        except Exception:
                            logs = []
                        for log_path in logs[:400]:
                            try:
                                with log_path.open("r", encoding="utf-8", errors="ignore") as handle:
                                    first = handle.readline().strip()
                            except OSError:
                                continue
                            if not first:
                                continue
                            try:
                                entry = json.loads(first)
                            except Exception:
                                continue
                            if not isinstance(entry, dict) or entry.get("type") != "session_meta":
                                continue
                            payload = entry.get("payload") if isinstance(entry.get("payload"), dict) else {}
                            cwd = payload.get("cwd")
                            if isinstance(cwd, str) and cwd.strip() and normalize_path_for_match(cwd) in work_dirs:
                                has_history = True
                                sid = payload.get("id")
                                if isinstance(sid, str) and sid:
                                    session_id = sid
                                    break
                elif provider == "gemini":
                    gemini_root = Path.home() / ".gemini" / "tmp"
                    if gemini_root.exists():
                        import hashlib
                        candidates = [os.environ.get("PWD", ""), str(Path.cwd())]
                        try:
                            candidates.append(str(Path.cwd().resolve()))
                        except Exception:
                            pass
                        for candidate in candidates:
                            if not candidate:
                                continue
                            project_hash = hashlib.sha256(candidate.encode()).hexdigest()
                            chats_dir = gemini_root / project_hash / "chats"
                            if chats_dir.exists() and any(chats_dir.glob("session-*.json")):
                                has_history = True
                                break

                if has_history:
                    print(f"‚ÑπÔ∏è {provider}: Session ended but history recoverable")
                    if session_id:
                        print(f"   Session ID: {session_id[:8]}...")
                    print(f"   Use: ccb up {provider} -r")
                else:
                    print(f"‚ö†Ô∏è {provider}: Session ended, no recoverable history")
            else:
                print(f"‚ö†Ô∏è {provider}: Session lost, use ccb up {provider} -r to restart")

        except Exception as e:
            print(f"‚ùå {provider}: {e}")

    return 0


def cmd_version(args):
    """Show version info and check for updates"""
    script_root = Path(__file__).resolve().parent
    default_install_dir = Path.home() / ".local/share/codex-dual"
    install_dir = Path(os.environ.get("CODEX_INSTALL_PREFIX") or default_install_dir).expanduser()
    if (script_root / "install.sh").exists():
        install_dir = script_root

    local_info = get_version_info(install_dir)
    local_str = format_version_info(local_info)

    if is_json():
        set_output("version", local_str)
        set_output("install_path", str(install_dir))
        set_output("local_info", local_info)

        print_msg("\nChecking for updates...")
        remote_info = get_remote_version_info()
        if remote_info:
            set_output("remote_info", remote_info)
            set_output("update_available", local_info.get("commit") != remote_info.get("commit"))
        return flush_json(0)

    print_msg(f"ccb (Claude Code Bridge) {local_str}")
    print_msg(f"Install path: {install_dir}")

    print_msg("\nChecking for updates...")
    remote_info = get_remote_version_info()

    if remote_info is None:
        print_msg("‚ö†Ô∏è  Unable to check for updates (network error)")
    elif local_info.get("commit") and remote_info.get("commit"):
        if local_info["commit"] == remote_info["commit"]:
            print_msg(f"‚úÖ Up to date")
        else:
            remote_str = f"{remote_info['commit']} {remote_info.get('date', '')}"
            print_msg(f"üì¶ Update available: {remote_str}")
            print_msg(f"   Run: ccb update")
    else:
        print_msg("‚ö†Ô∏è  Unable to compare versions")

    return 0


def cmd_update(args):
    """Update ccb to latest version"""
    # Prefer the directory where this script resides (installed copy), then fall back to env/default.
    script_root = Path(__file__).resolve().parent
    default_install_dir = Path.home() / ".local/share/codex-dual"
    install_dir = Path(os.environ.get("CODEX_INSTALL_PREFIX") or default_install_dir).expanduser()
    if (script_root / "install.sh").exists():
        install_dir = script_root

    # Get current version info before update
    old_info = get_version_info(install_dir)

    print("üîÑ Checking for updates...")

    # Method 1: Prefer git if available
    success, message = update_from_git(install_dir)
    if success:
        print("üì¶ Updating via git pull...")
        print(message)
        print("üîß Reinstalling...")
        subprocess.run([str(install_dir / "install.sh"), "install"])
        # Show upgrade info
        new_info = get_version_info(install_dir)
        old_str = format_version_info(old_info)
        new_str = format_version_info(new_info)
        if old_info.get("commit") != new_info.get("commit"):
            print(f"‚úÖ Updated: {old_str} ‚Üí {new_str}")
        else:
            print(f"‚úÖ Already up to date: {new_str}")
        return ExitCode.SUCCESS
    elif "Git not available" not in message:
        print(f"‚ö†Ô∏è {message}")
        print("Falling back to tarball download...")

    # Method 2: Download tarball
    print("üì• Downloading latest version...")
    success, message = update_from_tarball(install_dir)
    if success:
        # Show upgrade info
        new_info = get_version_info(install_dir)
        old_str = format_version_info(old_info)
        new_str = format_version_info(new_info)
        if old_info.get("commit") != new_info.get("commit") or old_info.get("version") != new_info.get("version"):
            print(f"‚úÖ Updated: {old_str} ‚Üí {new_str}")
        else:
            print(f"‚úÖ Already up to date: {new_str}")
        return ExitCode.SUCCESS
    else:
        return print_error_and_exit(ExitCode.UPDATE_FAILED, message)


def cmd_doctor(args):
    """Run system diagnostics"""
    passed, failed = run_diagnostics(verbose=getattr(args, 'verbose', False))
    return 0 if failed == 0 else 1


def cmd_init(args):
    """Run interactive configuration wizard"""
    from pathlib import Path
    config_path = args.config if args.config else None
    if config_path:
        config_path = Path(config_path)

    # Check for existing config
    check_path = config_path or Path.cwd() / ".ccb-config.json"
    if check_path.exists() and not args.force:
        print(f"Configuration file already exists: {check_path}")
        response = input("Overwrite existing configuration? [y/N]: ").strip().lower()
        if response not in ("y", "yes"):
            return print_error_and_exit(ExitCode.CONFIG_PERMISSION, "Use --force to overwrite, or specify a different path with --config")

    config = run_init_wizard(config_path)
    return ExitCode.SUCCESS if config else ExitCode.GENERAL_ERROR


def cmd_completion(args):
    """Output shell completion script"""
    shell = args.shell or "zsh"

    # Get the completions directory
    completions_dir = script_dir / "completions"

    if shell == "zsh":
        completion_file = completions_dir / "_ccb"
        if completion_file.exists():
            print(completion_file.read_text())
            print("\n# To install, add to your ~/.zshrc:")
            print(f"# fpath=({completions_dir} $fpath)")
            print("# autoload -Uz compinit && compinit")
        else:
            return print_error_and_exit(ExitCode.CONFIG_NOT_FOUND, f"Completion file not found: {completion_file}")
    else:
        return print_error_and_exit(ExitCode.USAGE_ERROR, f"Unsupported shell: {shell}. Only 'zsh' is supported on macOS.")

    return ExitCode.SUCCESS


def cmd_examples(args):
    """Show detailed usage examples"""
    examples_text = """ccb Usage Examples
==================

Starting AI Backends:
  ccb up codex                    # Start Codex backend only
  ccb up gemini                   # Start Gemini backend only
  ccb up codex gemini             # Start both backends
  ccb up                          # Start default backend (codex)

Resume Previous Context:
  ccb up -r                       # Resume with previous session context
  ccb up codex -r                 # Resume Codex with previous context
  ccb -r                          # Shortcut for 'ccb up -r'

Auto Permission Mode:
  ccb up -a                       # Start with full auto permission
  ccb up codex gemini -a -r       # Resume both with auto permission

Session Management:
  ccb status                      # Check status of all backends
  ccb status codex                # Check Codex status only
  ccb kill                        # Terminate all sessions
  ccb kill gemini                 # Terminate Gemini only
  ccb restore codex               # Restore/attach to Codex session

System Commands:
  ccb init                        # Run interactive configuration wizard
  ccb init -f                     # Force overwrite existing config
  ccb doctor                      # Run system diagnostics
  ccb doctor -v                   # Verbose diagnostics
  ccb update                      # Update ccb to latest version
  ccb version                     # Show version and check for updates

Output Control:
  ccb status --json               # Output status in JSON format
  ccb status -q                   # Quiet mode (minimal output)
  ccb --debug status              # Enable debug output

Shell Completion:
  ccb completion zsh              # Output zsh completion script
  eval "$(ccb completion zsh)"    # Enable completion in current shell

Communication Commands (via bridge):
  cask "message"                  # Send message to Codex (fire and forget)
  cask-w "message"                # Send to Codex and wait for reply
  gask "message"                  # Send message to Gemini
  gask-w "message"                # Send to Gemini and wait for reply
  cping                           # Check Codex connectivity
  gping                           # Check Gemini connectivity

Environment Variables:
  CCB_QUIET=1                     # Enable quiet mode globally
  CCB_DEBUG=1                     # Enable debug mode globally
  CCB_BACKEND_ENV=wsl             # Force WSL backend environment
"""
    print(examples_text.strip())
    return ExitCode.SUCCESS


def main():
    parser = argparse.ArgumentParser(description="Claude AI unified launcher", add_help=False)
    # Global options
    parser.add_argument("-h", "--help", action="store_true", help="Show help message")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress non-essential output")
    parser.add_argument("--json", action="store_true", help="Output in JSON format")
    parser.add_argument("--debug", action="store_true", help="Enable debug output for troubleshooting")

    subparsers = parser.add_subparsers(dest="command", help="Subcommands")

    # up subcommand
    up_parser = subparsers.add_parser("up", help="Start AI backends")
    up_parser.add_argument("providers", nargs="*", choices=["codex", "gemini"], help="Backends to start")
    up_parser.add_argument("-r", "--resume", "--restore", action="store_true", help="Resume context")
    up_parser.add_argument("-a", "--auto", action="store_true", help="Full auto permission mode")
    up_parser.add_argument("--no-claude", action="store_true", help="Don't start Claude main window")

    # status subcommand
    status_parser = subparsers.add_parser("status", help="Check status")
    status_parser.add_argument("providers", nargs="*", default=[], help="Backends to check (codex/gemini)")

    # kill subcommand
    kill_parser = subparsers.add_parser("kill", help="Terminate session")
    kill_parser.add_argument("providers", nargs="*", default=[], help="Backends to terminate (codex/gemini)")

    # restore subcommand
    restore_parser = subparsers.add_parser("restore", help="Restore/attach session")
    restore_parser.add_argument("providers", nargs="*", default=[], help="Backends to restore (codex/gemini)")

    # update subcommand
    subparsers.add_parser("update", help="Update to latest version")

    # version subcommand
    subparsers.add_parser("version", help="Show version and check for updates")

    # doctor subcommand
    doctor_parser = subparsers.add_parser("doctor", help="Run system diagnostics")
    doctor_parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    # init subcommand
    init_parser = subparsers.add_parser("init", help="Interactive configuration wizard")
    init_parser.add_argument("-c", "--config", type=str, help="Path to save configuration file")
    init_parser.add_argument("-f", "--force", action="store_true", help="Overwrite existing configuration")

    # completion subcommand
    completion_parser = subparsers.add_parser("completion", help="Output shell completion script")
    completion_parser.add_argument("shell", nargs="?", default="zsh", help="Shell type (default: zsh)")

    # examples subcommand
    subparsers.add_parser("examples", help="Show detailed usage examples")

    # ask subcommand
    ask_parser = subparsers.add_parser("ask", help="Send message to AI providers in parallel")
    ask_parser.add_argument("message", nargs="*", help="Message to send")
    ask_parser.add_argument("-p", "--providers", type=str, help="Comma-separated providers (codex,gemini)")
    ask_parser.add_argument("-a", "--all", action="store_true", help="Send to all providers")
    ask_parser.add_argument("-w", "--wait", action="store_true", default=True, help="Wait for replies (default)")
    ask_parser.add_argument("--no-wait", action="store_true", help="Fire and forget mode")
    ask_parser.add_argument("-t", "--timeout", type=int, default=0, help="Timeout in seconds (0=unlimited)")

    argv = sys.argv[1:]
    # Backward/shortcut compatibility
    if argv and argv[0] in {"-r", "--resume", "--restore"}:
        argv = ["up"] + argv
    elif argv and argv[0] in {"-v", "--version"}:
        argv = ["version"]
    args = parser.parse_args(argv)

    # Initialize output settings
    init_output(quiet=args.quiet, json_output=args.json, debug=args.debug)

    # Handle help flag
    if args.help:
        print_custom_help()
        return 0

    if not args.command:
        if not is_json():
            print_custom_help()
        return 0

    if args.command == "up":
        return cmd_up(args)
    elif args.command == "status":
        return cmd_status(args)
    elif args.command == "kill":
        return cmd_kill(args)
    elif args.command == "restore":
        return cmd_restore(args)
    elif args.command == "update":
        return cmd_update(args)
    elif args.command == "version":
        return cmd_version(args)
    elif args.command == "doctor":
        return cmd_doctor(args)
    elif args.command == "init":
        return cmd_init(args)
    elif args.command == "completion":
        return cmd_completion(args)
    elif args.command == "examples":
        return cmd_examples(args)
    elif args.command == "ask":
        # Handle --no-wait flag
        if getattr(args, "no_wait", False):
            args.wait = False
        return cmd_ask(args)
    else:
        if not is_json():
            print_custom_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())
