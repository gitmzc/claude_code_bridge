#!/usr/bin/env python3
"""
ccb (Claude Code Bridge) - Unified AI Launcher
Supports Claude + Codex / Claude + Gemini / all three simultaneously
Supports tmux, WezTerm and iTerm2 terminals
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import platform
import tempfile
import re
import shutil
from pathlib import Path

script_dir = Path(__file__).resolve().parent
sys.path.insert(0, str(script_dir / "lib"))
from terminal import TmuxBackend, WeztermBackend, Iterm2Backend, detect_terminal, is_wsl, get_shell_type
from compat import setup_windows_encoding
from ccb_config import get_backend_env
from session_utils import safe_write_session, check_session_writable
from i18n import t
from path_utils import (
    normalize_path_for_match,
    work_dir_match_keys,
    extract_session_work_dir_norm,
)
from updater import (
    get_version_info,
    format_version_info,
    get_remote_version_info,
    update_from_git,
    update_from_tarball,
)
from constants import VERSION, VALID_PROVIDERS
from launcher import AILauncher
from doctor import run_diagnostics
from init_wizard import run_init_wizard
from output import init_output, is_quiet, is_json, print_msg, print_error, set_output, add_to_list, flush_json

setup_windows_encoding()

backend_env = get_backend_env()
if backend_env and not os.environ.get("CCB_BACKEND_ENV"):
    os.environ["CCB_BACKEND_ENV"] = backend_env


def cmd_up(args):
    launcher = AILauncher(
        providers=args.providers or ["codex"],
        resume=args.resume,
        auto=args.auto,
        no_claude=args.no_claude,
    )
    return launcher.run_up()


def cmd_status(args):
    providers = args.providers or ["codex", "gemini"]
    results = {}

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            results[provider] = {"status": "Not configured", "active": False}
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else data.get("tmux_session", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                alive = backend.is_alive(pane_id)
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                alive = backend.is_alive(pane_id)
            elif pane_id and shutil.which("tmux"):
                result = subprocess.run(["tmux", "has-session", "-t", pane_id], capture_output=True)
                alive = result.returncode == 0
            else:
                alive = False

            results[provider] = {
                "status": "Running" if (active and alive) else "Stopped",
                "active": active and alive,
                "terminal": terminal,
                "pane_id": pane_id,
                "runtime_dir": data.get("runtime_dir", ""),
            }
        except Exception as e:
            results[provider] = {"status": f"Error: {e}", "active": False}

    if is_json():
        set_output("providers", results)
        return flush_json(0)

    print_msg(f"üìä {t('backend_status')}")
    for provider, info in results.items():
        icon = "‚úÖ" if info.get("active") else "‚ùå"
        print_msg(f"  {icon} {provider.capitalize()}: {info['status']}")
        if info.get("pane_id"):
            print_msg(f"     {info.get('terminal', 'tmux')}: {info['pane_id']}")

    return 0


def cmd_kill(args):
    providers = args.providers or ["codex", "gemini"]
    results = []

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print_msg(f"‚ö†Ô∏è {provider}: Session file not found")
            results.append({"provider": provider, "success": False, "error": "Session file not found"})
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else data.get("tmux_session", "")

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                backend.kill_pane(pane_id)
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                backend.kill_pane(pane_id)
            elif pane_id and shutil.which("tmux"):
                subprocess.run(["tmux", "kill-session", "-t", pane_id], stderr=subprocess.DEVNULL)
                subprocess.run(["tmux", "kill-session", "-t", f"launcher-{pane_id}"], stderr=subprocess.DEVNULL)

            data["active"] = False
            data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
            safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))

            print_msg(f"‚úÖ {provider.capitalize()} terminated")
            results.append({"provider": provider, "success": True})
        except Exception as e:
            print_error(f"‚ùå {provider}: {e}")
            results.append({"provider": provider, "success": False, "error": str(e)})

    if is_json():
        set_output("results", results)
        return flush_json(0)

    return 0


def cmd_restore(args):
    providers = args.providers or ["codex"]

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print(f"‚ö†Ô∏è {provider}: Session file not found")
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else data.get("tmux_session", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                if backend.is_alive(pane_id):
                    backend.activate(pane_id)
                    return 0
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                if backend.is_alive(pane_id):
                    backend.activate(pane_id)
                    return 0
            elif pane_id and shutil.which("tmux"):
                result = subprocess.run(["tmux", "has-session", "-t", pane_id], capture_output=True)
                if result.returncode == 0:
                    subprocess.run(["tmux", "attach-session", "-t", pane_id])
                    return 0

            if not active:
                has_history = False
                session_id = None
                if provider == "codex":
                    session_id = data.get("codex_session_id")
                    if isinstance(session_id, str) and session_id:
                        recorded_norm = extract_session_work_dir_norm(data)
                        work_keys = work_dir_match_keys(Path.cwd())
                        if recorded_norm and (not work_keys or recorded_norm in work_keys):
                            has_history = True
                        else:
                            session_id = None
                    else:
                        # Fallback: scan ~/.codex/sessions for latest session bound to this cwd.
                        root = Path(os.environ.get("CODEX_SESSION_ROOT") or (Path.home() / ".codex" / "sessions")).expanduser()
                        work_dirs = work_dir_match_keys(Path.cwd())
                        try:
                            logs = sorted(
                                (p for p in root.glob("**/*.jsonl") if p.is_file()),
                                key=lambda p: p.stat().st_mtime,
                                reverse=True,
                            )
                        except Exception:
                            logs = []
                        for log_path in logs[:400]:
                            try:
                                with log_path.open("r", encoding="utf-8", errors="ignore") as handle:
                                    first = handle.readline().strip()
                            except OSError:
                                continue
                            if not first:
                                continue
                            try:
                                entry = json.loads(first)
                            except Exception:
                                continue
                            if not isinstance(entry, dict) or entry.get("type") != "session_meta":
                                continue
                            payload = entry.get("payload") if isinstance(entry.get("payload"), dict) else {}
                            cwd = payload.get("cwd")
                            if isinstance(cwd, str) and cwd.strip() and normalize_path_for_match(cwd) in work_dirs:
                                has_history = True
                                sid = payload.get("id")
                                if isinstance(sid, str) and sid:
                                    session_id = sid
                                    break
                elif provider == "gemini":
                    gemini_root = Path.home() / ".gemini" / "tmp"
                    if gemini_root.exists():
                        import hashlib
                        candidates = [os.environ.get("PWD", ""), str(Path.cwd())]
                        try:
                            candidates.append(str(Path.cwd().resolve()))
                        except Exception:
                            pass
                        for candidate in candidates:
                            if not candidate:
                                continue
                            project_hash = hashlib.sha256(candidate.encode()).hexdigest()
                            chats_dir = gemini_root / project_hash / "chats"
                            if chats_dir.exists() and any(chats_dir.glob("session-*.json")):
                                has_history = True
                                break

                if has_history:
                    print(f"‚ÑπÔ∏è {provider}: Session ended but history recoverable")
                    if session_id:
                        print(f"   Session ID: {session_id[:8]}...")
                    print(f"   Use: ccb up {provider} -r")
                else:
                    print(f"‚ö†Ô∏è {provider}: Session ended, no recoverable history")
            else:
                print(f"‚ö†Ô∏è {provider}: Session lost, use ccb up {provider} -r to restart")

        except Exception as e:
            print(f"‚ùå {provider}: {e}")

    return 0


def cmd_version(args):
    """Show version info and check for updates"""
    script_root = Path(__file__).resolve().parent
    default_install_dir = Path.home() / ".local/share/codex-dual"
    install_dir = Path(os.environ.get("CODEX_INSTALL_PREFIX") or default_install_dir).expanduser()
    if (script_root / "install.sh").exists():
        install_dir = script_root

    local_info = get_version_info(install_dir)
    local_str = format_version_info(local_info)

    if is_json():
        set_output("version", local_str)
        set_output("install_path", str(install_dir))
        set_output("local_info", local_info)

        print_msg("\nChecking for updates...")
        remote_info = get_remote_version_info()
        if remote_info:
            set_output("remote_info", remote_info)
            set_output("update_available", local_info.get("commit") != remote_info.get("commit"))
        return flush_json(0)

    print_msg(f"ccb (Claude Code Bridge) {local_str}")
    print_msg(f"Install path: {install_dir}")

    print_msg("\nChecking for updates...")
    remote_info = get_remote_version_info()

    if remote_info is None:
        print_msg("‚ö†Ô∏è  Unable to check for updates (network error)")
    elif local_info.get("commit") and remote_info.get("commit"):
        if local_info["commit"] == remote_info["commit"]:
            print_msg(f"‚úÖ Up to date")
        else:
            remote_str = f"{remote_info['commit']} {remote_info.get('date', '')}"
            print_msg(f"üì¶ Update available: {remote_str}")
            print_msg(f"   Run: ccb update")
    else:
        print_msg("‚ö†Ô∏è  Unable to compare versions")

    return 0


def cmd_update(args):
    """Update ccb to latest version"""
    # Prefer the directory where this script resides (installed copy), then fall back to env/default.
    script_root = Path(__file__).resolve().parent
    default_install_dir = Path.home() / ".local/share/codex-dual"
    install_dir = Path(os.environ.get("CODEX_INSTALL_PREFIX") or default_install_dir).expanduser()
    if (script_root / "install.sh").exists():
        install_dir = script_root

    # Get current version info before update
    old_info = get_version_info(install_dir)

    print("üîÑ Checking for updates...")

    # Method 1: Prefer git if available
    success, message = update_from_git(install_dir)
    if success:
        print("üì¶ Updating via git pull...")
        print(message)
        print("üîß Reinstalling...")
        subprocess.run([str(install_dir / "install.sh"), "install"])
        # Show upgrade info
        new_info = get_version_info(install_dir)
        old_str = format_version_info(old_info)
        new_str = format_version_info(new_info)
        if old_info.get("commit") != new_info.get("commit"):
            print(f"‚úÖ Updated: {old_str} ‚Üí {new_str}")
        else:
            print(f"‚úÖ Already up to date: {new_str}")
        return 0
    elif "Git not available" not in message:
        print(f"‚ö†Ô∏è {message}")
        print("Falling back to tarball download...")

    # Method 2: Download tarball
    print("üì• Downloading latest version...")
    success, message = update_from_tarball(install_dir)
    if success:
        # Show upgrade info
        new_info = get_version_info(install_dir)
        old_str = format_version_info(old_info)
        new_str = format_version_info(new_info)
        if old_info.get("commit") != new_info.get("commit") or old_info.get("version") != new_info.get("version"):
            print(f"‚úÖ Updated: {old_str} ‚Üí {new_str}")
        else:
            print(f"‚úÖ Already up to date: {new_str}")
        return 0
    else:
        print(f"‚ùå {message}")
        return 1


def cmd_doctor(args):
    """Run system diagnostics"""
    passed, failed = run_diagnostics(verbose=getattr(args, 'verbose', False))
    return 0 if failed == 0 else 1


def cmd_init(args):
    """Run interactive configuration wizard"""
    from pathlib import Path
    config_path = args.config if args.config else None
    if config_path:
        config_path = Path(config_path)

    # Check for existing config
    check_path = config_path or Path.cwd() / ".ccb-config.json"
    if check_path.exists() and not args.force:
        print(f"Configuration file already exists: {check_path}")
        response = input("Overwrite existing configuration? [y/N]: ").strip().lower()
        if response not in ("y", "yes"):
            print("Use --force to overwrite, or specify a different path with --config")
            return 1

    config = run_init_wizard(config_path)
    return 0 if config else 1


def cmd_completion(args):
    """Output shell completion script"""
    shell = args.shell or "zsh"

    # Get the completions directory
    completions_dir = script_dir / "completions"

    if shell == "zsh":
        completion_file = completions_dir / "_ccb"
        if completion_file.exists():
            print(completion_file.read_text())
            print("\n# To install, add to your ~/.zshrc:")
            print(f"# fpath=({completions_dir} $fpath)")
            print("# autoload -Uz compinit && compinit")
        else:
            print(f"Error: Completion file not found: {completion_file}", file=sys.stderr)
            return 1
    else:
        print(f"Unsupported shell: {shell}. Only 'zsh' is supported on macOS.", file=sys.stderr)
        return 1

    return 0


def main():
    parser = argparse.ArgumentParser(description="Claude AI unified launcher", add_help=True)
    # Global options
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress non-essential output")
    parser.add_argument("--json", action="store_true", help="Output in JSON format")

    subparsers = parser.add_subparsers(dest="command", help="Subcommands")

    # up subcommand
    up_parser = subparsers.add_parser("up", help="Start AI backends")
    up_parser.add_argument("providers", nargs="*", choices=["codex", "gemini"], help="Backends to start")
    up_parser.add_argument("-r", "--resume", "--restore", action="store_true", help="Resume context")
    up_parser.add_argument("-a", "--auto", action="store_true", help="Full auto permission mode")
    up_parser.add_argument("--no-claude", action="store_true", help="Don't start Claude main window")

    # status subcommand
    status_parser = subparsers.add_parser("status", help="Check status")
    status_parser.add_argument("providers", nargs="*", default=[], help="Backends to check (codex/gemini)")

    # kill subcommand
    kill_parser = subparsers.add_parser("kill", help="Terminate session")
    kill_parser.add_argument("providers", nargs="*", default=[], help="Backends to terminate (codex/gemini)")

    # restore subcommand
    restore_parser = subparsers.add_parser("restore", help="Restore/attach session")
    restore_parser.add_argument("providers", nargs="*", default=[], help="Backends to restore (codex/gemini)")

    # update subcommand
    subparsers.add_parser("update", help="Update to latest version")

    # version subcommand
    subparsers.add_parser("version", help="Show version and check for updates")

    # doctor subcommand
    doctor_parser = subparsers.add_parser("doctor", help="Run system diagnostics")
    doctor_parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    # init subcommand
    init_parser = subparsers.add_parser("init", help="Interactive configuration wizard")
    init_parser.add_argument("-c", "--config", type=str, help="Path to save configuration file")
    init_parser.add_argument("-f", "--force", action="store_true", help="Overwrite existing configuration")

    # completion subcommand
    completion_parser = subparsers.add_parser("completion", help="Output shell completion script")
    completion_parser.add_argument("shell", nargs="?", default="zsh", help="Shell type (default: zsh)")

    argv = sys.argv[1:]
    # Backward/shortcut compatibility
    if argv and argv[0] in {"-r", "--resume", "--restore"}:
        argv = ["up"] + argv
    elif argv and argv[0] in {"-v", "--version"}:
        argv = ["version"]
    args = parser.parse_args(argv)

    # Initialize output settings
    init_output(quiet=args.quiet, json_output=args.json)

    if not args.command:
        if not is_json():
            parser.print_help()
        return 0

    if args.command == "up":
        return cmd_up(args)
    elif args.command == "status":
        return cmd_status(args)
    elif args.command == "kill":
        return cmd_kill(args)
    elif args.command == "restore":
        return cmd_restore(args)
    elif args.command == "update":
        return cmd_update(args)
    elif args.command == "version":
        return cmd_version(args)
    elif args.command == "doctor":
        return cmd_doctor(args)
    elif args.command == "init":
        return cmd_init(args)
    elif args.command == "completion":
        return cmd_completion(args)
    else:
        if not is_json():
            parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())
